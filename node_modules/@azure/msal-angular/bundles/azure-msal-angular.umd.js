(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('@azure/msal-browser'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@azure/msal-angular', ['exports', '@angular/core', '@angular/common', 'rxjs', '@azure/msal-browser', 'rxjs/operators'], factory) :
    (global = global || self, factory((global.azure = global.azure || {}, global.azure['msal-angular'] = {}), global.ng.core, global.ng.common, global.rxjs, global['@azure/msal-browser'], global.rxjs.operators));
}(this, (function (exports, core, common, rxjs, msalBrowser, operators) { 'use strict';

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MSAL_INSTANCE = new core.InjectionToken("MSAL_INSTANCE");
    var MSAL_GUARD_CONFIG = new core.InjectionToken("MSAL_GUARD_CONFIG");
    var MSAL_INTERCEPTOR_CONFIG = new core.InjectionToken("MSAL_INTERCEPTOR_CONFIG");
    var name = "@azure/msal-angular";
    var version = "2.0.0-alpha.0";

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalService = /** @class */ (function () {
        function MsalService(instance, location) {
            this.instance = instance;
            this.location = location;
            var hash = this.location.path(true).split("#").pop();
            if (hash) {
                this.redirectHash = "#" + hash;
            }
        }
        MsalService.prototype.acquireTokenPopup = function (request) {
            return rxjs.from(this.instance.acquireTokenPopup(request));
        };
        MsalService.prototype.acquireTokenRedirect = function (request) {
            return rxjs.from(this.instance.acquireTokenRedirect(request));
        };
        MsalService.prototype.acquireTokenSilent = function (silentRequest) {
            return rxjs.from(this.instance.acquireTokenSilent(silentRequest));
        };
        MsalService.prototype.handleRedirectObservable = function () {
            var handleRedirect = rxjs.from(this.instance.handleRedirectPromise(this.redirectHash));
            this.redirectHash = "";
            return handleRedirect;
        };
        MsalService.prototype.loginPopup = function (request) {
            return rxjs.from(this.instance.loginPopup(request));
        };
        MsalService.prototype.loginRedirect = function (request) {
            return rxjs.from(this.instance.loginRedirect(request));
        };
        MsalService.prototype.logout = function (logoutRequest) {
            return rxjs.from(this.instance.logout(logoutRequest));
        };
        MsalService.prototype.ssoSilent = function (request) {
            return rxjs.from(this.instance.ssoSilent(request));
        };
        MsalService.prototype.getLogger = function () {
            if (!this.logger) {
                this.logger = this.instance.getLogger().clone(name, version);
            }
            return this.logger;
        };
        MsalService.prototype.setLogger = function (logger) {
            this.logger = logger.clone(name, version);
            this.instance.setLogger(logger);
        };
        return MsalService;
    }());
    MsalService.decorators = [
        { type: core.Injectable }
    ];
    MsalService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_INSTANCE,] }] },
        { type: common.Location }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalGuard = /** @class */ (function () {
        function MsalGuard(msalGuardConfig, authService, location) {
            this.msalGuardConfig = msalGuardConfig;
            this.authService = authService;
            this.location = location;
        }
        /**
         * Builds the absolute url for the destination page
         * @param path Relative path of requested page
         * @returns Full destination url
         */
        MsalGuard.prototype.getDestinationUrl = function (path) {
            this.authService.getLogger().verbose("Guard - getting destination url");
            // Absolute base url for the application (default to origin if base element not present)
            var baseElements = document.getElementsByTagName("base");
            var baseUrl = this.location.normalize(baseElements.length ? baseElements[0].href : window.location.origin);
            // Path of page (including hash, if using hash routing)
            var pathUrl = this.location.prepareExternalUrl(path);
            // Hash location strategy
            if (pathUrl.startsWith("#")) {
                this.authService.getLogger().verbose("Guard - destination by hash routing");
                return baseUrl + "/" + pathUrl;
            }
            /*
             * If using path location strategy, pathUrl will include the relative portion of the base path (e.g. /base/page).
             * Since baseUrl also includes /base, can just concatentate baseUrl + path
             */
            return "" + baseUrl + path;
        };
        MsalGuard.prototype.loginInteractively = function (url) {
            var _this = this;
            if (this.msalGuardConfig.interactionType === msalBrowser.InteractionType.Popup) {
                this.authService.getLogger().verbose("Guard - logging in by popup");
                return this.authService.loginPopup(Object.assign({}, this.msalGuardConfig.authRequest))
                    .pipe(operators.map(function () {
                    _this.authService.getLogger().verbose("Guard - login by popup successful, can activate");
                    return true;
                }), operators.catchError(function () { return rxjs.of(false); }));
            }
            this.authService.getLogger().verbose("Guard - logging in by redirect");
            var redirectStartPage = this.getDestinationUrl(url);
            this.authService.loginRedirect(Object.assign({ redirectStartPage: redirectStartPage }, this.msalGuardConfig.authRequest));
            return rxjs.of(false);
        };
        MsalGuard.prototype.canActivate = function (route, state) {
            var _this = this;
            if (this.msalGuardConfig.interactionType !== msalBrowser.InteractionType.Popup && this.msalGuardConfig.interactionType !== msalBrowser.InteractionType.Redirect) {
                throw new msalBrowser.BrowserConfigurationAuthError("invalid_interaction_type", "Invalid interaction type provided to MSAL Guard. InteractionType.Popup or InteractionType.Redirect must be provided in the MsalGuardConfiguration");
            }
            this.authService.getLogger().verbose("MSAL Guard activated");
            /*
             * If a page with MSAL Guard is set as the redirect for acquireTokenSilent,
             * short-circuit to prevent redirecting or popups.
             * TODO: Update to allow running in iframe once allowRedirectInIframe is implemented
             */
            if (msalBrowser.UrlString.hashContainsKnownProperties(window.location.hash) && msalBrowser.BrowserUtils.isInIframe()) {
                this.authService.getLogger().warning("Guard - redirectUri set to page with MSAL Guard. It is recommended to not set redirectUri to a page that requires authentication.");
                return rxjs.of(false);
            }
            return this.authService.handleRedirectObservable()
                .pipe(operators.concatMap(function () {
                if (!_this.authService.instance.getAllAccounts().length) {
                    _this.authService.getLogger().verbose("Guard - no accounts retrieved, log in required to activate");
                    return _this.loginInteractively(state.url);
                }
                _this.authService.getLogger().verbose("Guard - account retrieved, can activate");
                return rxjs.of(true);
            }), operators.catchError(function () {
                _this.authService.getLogger().verbose("Guard - error while logging in, unable to activate");
                return rxjs.of(false);
            }));
        };
        return MsalGuard;
    }());
    MsalGuard.decorators = [
        { type: core.Injectable }
    ];
    MsalGuard.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_GUARD_CONFIG,] }] },
        { type: MsalService },
        { type: common.Location }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalInterceptor = /** @class */ (function () {
        function MsalInterceptor(msalInterceptorConfig, authService) {
            this.msalInterceptorConfig = msalInterceptorConfig;
            this.authService = authService;
        }
        MsalInterceptor.prototype.intercept = function (req, next) {
            var _this = this;
            if (this.msalInterceptorConfig.interactionType !== msalBrowser.InteractionType.Popup && this.msalInterceptorConfig.interactionType !== msalBrowser.InteractionType.Redirect) {
                throw new msalBrowser.BrowserConfigurationAuthError("invalid_interaction_type", "Invalid interaction type provided to MSAL Interceptor. InteractionType.Popup, InteractionType.Redirect must be provided in the msalInterceptorConfiguration");
            }
            this.authService.getLogger().verbose("MSAL Interceptor activated");
            var scopes = this.getScopesForEndpoint(req.url);
            var account = this.authService.instance.getAllAccounts()[0];
            if (!scopes || scopes.length === 0) {
                this.authService.getLogger().verbose("Interceptor - no scopes for endpoint");
                return next.handle(req);
            }
            // Note: For MSA accounts, include openid scope when calling acquireTokenSilent to return idToken
            return this.authService.acquireTokenSilent(Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), { scopes: scopes, account: account }))
                .pipe(operators.catchError(function () {
                if (_this.msalInterceptorConfig.interactionType === msalBrowser.InteractionType.Popup) {
                    _this.authService.getLogger().verbose("Interceptor - error acquiring token silently, acquiring by popup");
                    return _this.authService.acquireTokenPopup(Object.assign(Object.assign({}, _this.msalInterceptorConfig.authRequest), { scopes: scopes }));
                }
                _this.authService.getLogger().verbose("Interceptor - error acquiring token silently, acquiring by redirect");
                var redirectStartPage = window.location.href;
                _this.authService.acquireTokenRedirect(Object.assign(Object.assign({}, _this.msalInterceptorConfig.authRequest), { scopes: scopes, redirectStartPage: redirectStartPage }));
                return rxjs.EMPTY;
            }), operators.switchMap(function (result) {
                _this.authService.getLogger().verbose("Interceptor - setting authorization headers");
                var headers = req.headers
                    .set("Authorization", "Bearer " + result.accessToken);
                var requestClone = req.clone({ headers: headers });
                return next.handle(requestClone);
            }));
        };
        MsalInterceptor.prototype.getScopesForEndpoint = function (endpoint) {
            this.authService.getLogger().verbose("Interceptor - getting scopes for endpoint");
            var protectedResourcesArray = Array.from(this.msalInterceptorConfig.protectedResourceMap.keys());
            var keyMatchesEndpointArray = protectedResourcesArray.filter(function (key) {
                return msalBrowser.StringUtils.matchPattern(key, endpoint);
            });
            // process all protected resources and send the first matched resource
            if (keyMatchesEndpointArray.length > 0) {
                var keyForEndpoint = keyMatchesEndpointArray[0];
                if (keyForEndpoint) {
                    return this.msalInterceptorConfig.protectedResourceMap.get(keyForEndpoint);
                }
            }
            return null;
        };
        return MsalInterceptor;
    }());
    MsalInterceptor.decorators = [
        { type: core.Injectable }
    ];
    MsalInterceptor.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_INTERCEPTOR_CONFIG,] }] },
        { type: MsalService }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalBroadcastService = /** @class */ (function () {
        function MsalBroadcastService(msalInstance) {
            var _this = this;
            this.msalInstance = msalInstance;
            this._msalSubject = new rxjs.Subject();
            this.msalSubject$ = this._msalSubject.asObservable();
            this.msalInstance.addEventCallback(function (message) {
                _this._msalSubject.next(message);
            });
        }
        return MsalBroadcastService;
    }());
    MsalBroadcastService.decorators = [
        { type: core.Injectable }
    ];
    MsalBroadcastService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [MSAL_INSTANCE,] }] }
    ]; };

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    var MsalModule = /** @class */ (function () {
        function MsalModule() {
        }
        MsalModule.forRoot = function (msalInstance, guardConfig, interceptorConfig) {
            return {
                ngModule: MsalModule,
                providers: [
                    {
                        provide: MSAL_INSTANCE,
                        useValue: msalInstance
                    },
                    {
                        provide: MSAL_GUARD_CONFIG,
                        useValue: guardConfig
                    },
                    {
                        provide: MSAL_INTERCEPTOR_CONFIG,
                        useValue: interceptorConfig
                    },
                    MsalService
                ]
            };
        };
        return MsalModule;
    }());
    MsalModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [],
                    imports: [
                        common.CommonModule
                    ],
                    providers: [
                        MsalGuard,
                        MsalBroadcastService
                    ]
                },] }
    ];

    /*
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.MSAL_GUARD_CONFIG = MSAL_GUARD_CONFIG;
    exports.MSAL_INSTANCE = MSAL_INSTANCE;
    exports.MSAL_INTERCEPTOR_CONFIG = MSAL_INTERCEPTOR_CONFIG;
    exports.MsalBroadcastService = MsalBroadcastService;
    exports.MsalGuard = MsalGuard;
    exports.MsalInterceptor = MsalInterceptor;
    exports.MsalModule = MsalModule;
    exports.MsalService = MsalService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=azure-msal-angular.umd.js.map
