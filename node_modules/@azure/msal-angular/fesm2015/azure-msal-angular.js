import { InjectionToken, Injectable, Inject, NgModule } from '@angular/core';
import { Location, CommonModule } from '@angular/common';
import { from, of, EMPTY, Subject } from 'rxjs';
import { InteractionType, BrowserConfigurationAuthError, UrlString, BrowserUtils, StringUtils } from '@azure/msal-browser';
import { map, catchError, concatMap, switchMap } from 'rxjs/operators';

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const MSAL_INSTANCE = new InjectionToken("MSAL_INSTANCE");
const MSAL_GUARD_CONFIG = new InjectionToken("MSAL_GUARD_CONFIG");
const MSAL_INTERCEPTOR_CONFIG = new InjectionToken("MSAL_INTERCEPTOR_CONFIG");
const name = "@azure/msal-angular";
const version = "2.0.0-alpha.0";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class MsalService {
    constructor(instance, location) {
        this.instance = instance;
        this.location = location;
        const hash = this.location.path(true).split("#").pop();
        if (hash) {
            this.redirectHash = `#${hash}`;
        }
    }
    acquireTokenPopup(request) {
        return from(this.instance.acquireTokenPopup(request));
    }
    acquireTokenRedirect(request) {
        return from(this.instance.acquireTokenRedirect(request));
    }
    acquireTokenSilent(silentRequest) {
        return from(this.instance.acquireTokenSilent(silentRequest));
    }
    handleRedirectObservable() {
        const handleRedirect = from(this.instance.handleRedirectPromise(this.redirectHash));
        this.redirectHash = "";
        return handleRedirect;
    }
    loginPopup(request) {
        return from(this.instance.loginPopup(request));
    }
    loginRedirect(request) {
        return from(this.instance.loginRedirect(request));
    }
    logout(logoutRequest) {
        return from(this.instance.logout(logoutRequest));
    }
    ssoSilent(request) {
        return from(this.instance.ssoSilent(request));
    }
    getLogger() {
        if (!this.logger) {
            this.logger = this.instance.getLogger().clone(name, version);
        }
        return this.logger;
    }
    setLogger(logger) {
        this.logger = logger.clone(name, version);
        this.instance.setLogger(logger);
    }
}
MsalService.decorators = [
    { type: Injectable }
];
MsalService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_INSTANCE,] }] },
    { type: Location }
];

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class MsalGuard {
    constructor(msalGuardConfig, authService, location) {
        this.msalGuardConfig = msalGuardConfig;
        this.authService = authService;
        this.location = location;
    }
    /**
     * Builds the absolute url for the destination page
     * @param path Relative path of requested page
     * @returns Full destination url
     */
    getDestinationUrl(path) {
        this.authService.getLogger().verbose("Guard - getting destination url");
        // Absolute base url for the application (default to origin if base element not present)
        const baseElements = document.getElementsByTagName("base");
        const baseUrl = this.location.normalize(baseElements.length ? baseElements[0].href : window.location.origin);
        // Path of page (including hash, if using hash routing)
        const pathUrl = this.location.prepareExternalUrl(path);
        // Hash location strategy
        if (pathUrl.startsWith("#")) {
            this.authService.getLogger().verbose("Guard - destination by hash routing");
            return `${baseUrl}/${pathUrl}`;
        }
        /*
         * If using path location strategy, pathUrl will include the relative portion of the base path (e.g. /base/page).
         * Since baseUrl also includes /base, can just concatentate baseUrl + path
         */
        return `${baseUrl}${path}`;
    }
    loginInteractively(url) {
        if (this.msalGuardConfig.interactionType === InteractionType.Popup) {
            this.authService.getLogger().verbose("Guard - logging in by popup");
            return this.authService.loginPopup(Object.assign({}, this.msalGuardConfig.authRequest))
                .pipe(map(() => {
                this.authService.getLogger().verbose("Guard - login by popup successful, can activate");
                return true;
            }), catchError(() => of(false)));
        }
        this.authService.getLogger().verbose("Guard - logging in by redirect");
        const redirectStartPage = this.getDestinationUrl(url);
        this.authService.loginRedirect(Object.assign({ redirectStartPage }, this.msalGuardConfig.authRequest));
        return of(false);
    }
    canActivate(route, state) {
        if (this.msalGuardConfig.interactionType !== InteractionType.Popup && this.msalGuardConfig.interactionType !== InteractionType.Redirect) {
            throw new BrowserConfigurationAuthError("invalid_interaction_type", "Invalid interaction type provided to MSAL Guard. InteractionType.Popup or InteractionType.Redirect must be provided in the MsalGuardConfiguration");
        }
        this.authService.getLogger().verbose("MSAL Guard activated");
        /*
         * If a page with MSAL Guard is set as the redirect for acquireTokenSilent,
         * short-circuit to prevent redirecting or popups.
         * TODO: Update to allow running in iframe once allowRedirectInIframe is implemented
         */
        if (UrlString.hashContainsKnownProperties(window.location.hash) && BrowserUtils.isInIframe()) {
            this.authService.getLogger().warning("Guard - redirectUri set to page with MSAL Guard. It is recommended to not set redirectUri to a page that requires authentication.");
            return of(false);
        }
        return this.authService.handleRedirectObservable()
            .pipe(concatMap(() => {
            if (!this.authService.instance.getAllAccounts().length) {
                this.authService.getLogger().verbose("Guard - no accounts retrieved, log in required to activate");
                return this.loginInteractively(state.url);
            }
            this.authService.getLogger().verbose("Guard - account retrieved, can activate");
            return of(true);
        }), catchError(() => {
            this.authService.getLogger().verbose("Guard - error while logging in, unable to activate");
            return of(false);
        }));
    }
}
MsalGuard.decorators = [
    { type: Injectable }
];
MsalGuard.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_GUARD_CONFIG,] }] },
    { type: MsalService },
    { type: Location }
];

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class MsalInterceptor {
    constructor(msalInterceptorConfig, authService) {
        this.msalInterceptorConfig = msalInterceptorConfig;
        this.authService = authService;
    }
    intercept(req, next) {
        if (this.msalInterceptorConfig.interactionType !== InteractionType.Popup && this.msalInterceptorConfig.interactionType !== InteractionType.Redirect) {
            throw new BrowserConfigurationAuthError("invalid_interaction_type", "Invalid interaction type provided to MSAL Interceptor. InteractionType.Popup, InteractionType.Redirect must be provided in the msalInterceptorConfiguration");
        }
        this.authService.getLogger().verbose("MSAL Interceptor activated");
        const scopes = this.getScopesForEndpoint(req.url);
        const account = this.authService.instance.getAllAccounts()[0];
        if (!scopes || scopes.length === 0) {
            this.authService.getLogger().verbose("Interceptor - no scopes for endpoint");
            return next.handle(req);
        }
        // Note: For MSA accounts, include openid scope when calling acquireTokenSilent to return idToken
        return this.authService.acquireTokenSilent(Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), { scopes, account }))
            .pipe(catchError(() => {
            if (this.msalInterceptorConfig.interactionType === InteractionType.Popup) {
                this.authService.getLogger().verbose("Interceptor - error acquiring token silently, acquiring by popup");
                return this.authService.acquireTokenPopup(Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), { scopes }));
            }
            this.authService.getLogger().verbose("Interceptor - error acquiring token silently, acquiring by redirect");
            const redirectStartPage = window.location.href;
            this.authService.acquireTokenRedirect(Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), { scopes, redirectStartPage }));
            return EMPTY;
        }), switchMap((result) => {
            this.authService.getLogger().verbose("Interceptor - setting authorization headers");
            const headers = req.headers
                .set("Authorization", `Bearer ${result.accessToken}`);
            const requestClone = req.clone({ headers });
            return next.handle(requestClone);
        }));
    }
    getScopesForEndpoint(endpoint) {
        this.authService.getLogger().verbose("Interceptor - getting scopes for endpoint");
        const protectedResourcesArray = Array.from(this.msalInterceptorConfig.protectedResourceMap.keys());
        const keyMatchesEndpointArray = protectedResourcesArray.filter(key => {
            return StringUtils.matchPattern(key, endpoint);
        });
        // process all protected resources and send the first matched resource
        if (keyMatchesEndpointArray.length > 0) {
            const keyForEndpoint = keyMatchesEndpointArray[0];
            if (keyForEndpoint) {
                return this.msalInterceptorConfig.protectedResourceMap.get(keyForEndpoint);
            }
        }
        return null;
    }
}
MsalInterceptor.decorators = [
    { type: Injectable }
];
MsalInterceptor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_INTERCEPTOR_CONFIG,] }] },
    { type: MsalService }
];

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class MsalBroadcastService {
    constructor(msalInstance) {
        this.msalInstance = msalInstance;
        this._msalSubject = new Subject();
        this.msalSubject$ = this._msalSubject.asObservable();
        this.msalInstance.addEventCallback((message) => {
            this._msalSubject.next(message);
        });
    }
}
MsalBroadcastService.decorators = [
    { type: Injectable }
];
MsalBroadcastService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MSAL_INSTANCE,] }] }
];

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
class MsalModule {
    static forRoot(msalInstance, guardConfig, interceptorConfig) {
        return {
            ngModule: MsalModule,
            providers: [
                {
                    provide: MSAL_INSTANCE,
                    useValue: msalInstance
                },
                {
                    provide: MSAL_GUARD_CONFIG,
                    useValue: guardConfig
                },
                {
                    provide: MSAL_INTERCEPTOR_CONFIG,
                    useValue: interceptorConfig
                },
                MsalService
            ]
        };
    }
}
MsalModule.decorators = [
    { type: NgModule, args: [{
                declarations: [],
                imports: [
                    CommonModule
                ],
                providers: [
                    MsalGuard,
                    MsalBroadcastService
                ]
            },] }
];

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MSAL_GUARD_CONFIG, MSAL_INSTANCE, MSAL_INTERCEPTOR_CONFIG, MsalBroadcastService, MsalGuard, MsalInterceptor, MsalModule, MsalService };
//# sourceMappingURL=azure-msal-angular.js.map
